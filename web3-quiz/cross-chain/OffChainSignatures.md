# Off-Chain Signatures in Ethereum
## What Are Off-Chain Signatures?
Off-chain signatures are cryptographic approvals generated by a user **without broadcasting a transaction directly to the blockchain**. Instead, the user signs structured data using their private key, and another actor (a relayer, a smart contract, or even an attacker) may later submit that signed message on-chain.

Examples:
- **ERC20 `permit()`** (EIP-2612): approve token spending without sending a transaction.
- **Meta-transactions**: user signs an intent, relayer pays gas.
- **Governance voting**: off-chain vote signatures aggregated on-chain.

---
## Why They Matter in Security
- **Efficiency**: Users save gas by not sending explicit `approve` or `vote` transactions.
- **Flexibility**: Off-chain messages can be aggregated, relayed, or bundled.

But they also introduce **replay attack surfaces** if the signed message is not tied to a specific context.

---
## Replay Risks
- If signatures **don’t include** `chainId`, they can be replayed across Ethereum Mainnet, Polygon, BSC, or forks.
- If signatures **don’t include** `verifyingContract`, they can be replayed across multiple deployed copies of the same contract.
- If **nonces** are missing or not enforced, the same signature can be reused indefinitely.

---
## Security Best Practices
1. **EIP-712 Typed Data**  
   Always use structured data signing. Include:
   - `chainId`
   - `verifyingContract`
   - `name` + `version` (optional, for app-level uniqueness)
2. **Nonces**  
   Every signed message should include a unique nonce that contracts check and consume.
3. **Expiration**  
   Use deadlines/timestamps to prevent signatures from being valid forever.
4. **Domain Separation**  
   The combination of `(chainId, verifyingContract, nonce)` ensures uniqueness.

---
## Example: ERC20 Permit (EIP-2612)

```solidity
function permit(
    address owner,
    address spender,
    uint256 value,
    uint256 deadline,
    uint8 v, bytes32 r, bytes32 s
) external {
    require(block.timestamp <= deadline, "EXPIRED");

    bytes32 digest = keccak256(
        abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR, // includes chainId + verifyingContract
            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
        )
    );
    address signer = ecrecover(digest, v, r, s);
    require(signer == owner, "INVALID_SIGNATURE");

    _approve(owner, spender, value);
}
```
---
## Auditor’s Checklist for Off-Chain Signatures
- Does the domain separator include `chainId` and `verifyingContract`?
- Are nonces implemented and incremented correctly?
- Is there an expiration (`deadline`) field to limit signature lifetime?
- Does the contract reject reused or expired signatures?

---
## Key Takeaways
**Off-chain signatures are powerful but dangerous**.  
Auditors must verify that signatures cannot be replayed across chains, contracts, or multiple times within the same contract.
